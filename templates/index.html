<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>deepSight — Uptime Dashboard</title>
  <link rel="stylesheet" href="/static/style.css">
  <style>
    /* small in-template fallback styles */
    body {
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: #0f1724;
      color: #e6eef8;
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <h1>deepSight</h1>
      <p class="muted">simple uptime & runtime dashboard</p>
    </header>

    <section class="grid">
      <div class="card">
        <h3>Uptime</h3>
        <div id="uptime" class="big">{{ .Uptime }}</div>
        <div id="startTime" class="muted">Started: {{ .StartTime }}</div>
      </div>

      <div class="card">
        <h3>Requests</h3>
        <div id="requestsTotal" class="big">{{ .RequestsTotal }}</div>
        <div id="requestsPerMin" class="muted">Last 60s: {{ .RequestsPerMin }}</div>
      </div>

      <div class="card">
        <h3>Host</h3>
        <div id="hostname" class="muted">{{ .Hostname }}</div>
        <div class="muted">Go: <span id="goversion">{{ .GoVersion }}</span> • Goroutines: <span id="goroutines">{{
            .NumGoroutine }}</span></div>
      </div>

      <div class="card">
        <h3>Memory</h3>
        <div id="memAlloc" class="big">{{ printf "%.2f" .MemAllocMB }} MiB</div>
      </div>
    </section>

    <section class="chart card">
      <h3>Requests (last 60s)</h3>
      <div id="sparkline" class="sparkline">
        {{ range .BarHeights }}
        <div class="bar" data-h="{{ . }}" title="{{ . }}"></div>
        {{ end }}
      </div>
    </section>

    <section class="card client">
      <h3>Client</h3>
      <div id="clientInfo" class="muted small">{{ .ClientIP }} • <strong>{{ .ClientMethod }}</strong> {{ .ClientPath }}
      </div>
      <div id="clientUA" class="muted small">UA: {{ .ClientUA }}</div>

      <details class="muted headers" style="margin-top:8px">
        <summary class="muted">Show headers</summary>
        <ul id="clientHeadersList">
          {{ range $k, $v := .ClientHeaders }}
          <li><strong>{{ $k }}:</strong> {{ $v }}</li>
          {{ end }}
        </ul>
      </details>
    </section>

    <footer class="muted">/health • /metrics • container-ready for k8s</footer>
  </div>

  <section class="container interactive" style="max-width:1100px;margin:20px auto;padding:6px">
    <div class="card">
      <h3>Interactive tools</h3>
      <!-- layout row: left controls, middle outputs, right load tester -->
      <div style="display:flex;gap:16px;align-items:flex-start;flex-wrap:wrap">
        <div style="flex:0 0 auto;display:flex;flex-direction:column;gap:8px">
          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <button id="btn-version">Get /version</button>
            <button id="btn-ready">Check /ready</button>
            <button id="btn-toggle-ready">Toggle readiness</button>
            <a class="muted" href="/debug/pprof/" target="_blank">pprof</a>
          </div>
        </div>

        <div style="flex:1 1 420px;min-width:300px;display:grid;grid-template-columns:1fr 1fr;gap:12px">
          <pre id="out-version"
            style="white-space:pre-wrap;word-break:break-word;background:#071025;padding:8px;border-radius:6px;min-height:60px">/version output</pre>
          <pre id="out-ready"
            style="white-space:pre-wrap;word-break:break-word;background:#071025;padding:8px;border-radius:6px;min-height:60px">/ready output</pre>
        </div>

        <div style="flex:0 0 420px;min-width:320px">
          <h4 style="margin:6px 0">Client-side load tester</h4>
          <div style="display:flex;gap:8px;align-items:center;flex-wrap:nowrap">
            <label class="muted">RPS:</label>
            <input id="load-rps" type="number" value="10" min="1"
              style="width:80px;padding:6px;border-radius:4px;background:#071025;color:var(--text);border:1px solid rgba(255,255,255,0.03)">
            <label class="muted">Duration (s):</label>
            <input id="load-dur" type="number" value="10" min="1"
              style="width:80px;padding:6px;border-radius:4px;background:#071025;color:var(--text);border:1px solid rgba(255,255,255,0.03)">
            <label class="muted">Mode:</label>
            <select id="load-mode"
              style="padding:6px;border-radius:4px;background:#071025;color:var(--text);border:1px solid rgba(255,255,255,0.03)">
              <option value="fixed">fixed</option>
              <option value="ramp" selected>ramp</option>
            </select>
            <label class="muted">Curve:</label>
            <select id="curve-type"
              style="padding:6px;border-radius:4px;background:#071025;color:var(--text);border:1px solid rgba(255,255,255,0.03)">
              <option value="linear">linear</option>
              <option value="sigmoid" selected>sigmoid</option>
              <option value="expo">exponential</option>
            </select>
          </div>
          <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
            <svg id="load-curve" width="240" height="60" style="background:#071025;border-radius:6px"></svg>
            <div style="display:flex;gap:8px;align-items:center">
              <button id="btn-start-load">Start load</button>
              <button id="btn-stop-load" disabled>Stop load</button>
              <div id="load-status" class="muted" style="margin-left:6px">idle</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>
  </section>

  <script>
    // set bar heights client-side to avoid template braces inside inline CSS
    (function () {
      try {
        document.querySelectorAll('.bar').forEach(function (el) {
          var h = el.getAttribute('data-h');
          if (!h) return;
          el.style.height = h + 'px';
        });
      } catch (e) {
        // noop
      }
    })();

    // small helper to fetch and show JSON/text
    async function fetchText(path, targetEl) {
      try {
        const res = await fetch(path);
        const txt = await res.text();
        document.getElementById(targetEl).textContent = txt;
      } catch (e) {
        document.getElementById(targetEl).textContent = String(e);
      }
    }

    document.getElementById('btn-version').addEventListener('click', function () { fetchText('/version', 'out-version'); });
    document.getElementById('btn-ready').addEventListener('click', function () { fetchText('/ready', 'out-ready'); });
    document.getElementById('btn-toggle-ready').addEventListener('click', async function () {
      try {
        // flip readiness
        const res = await fetch('/toggle-ready');
        const j = await res.json();
        document.getElementById('out-ready').textContent = JSON.stringify(j, null, 2);
      } catch (e) { document.getElementById('out-ready').textContent = String(e); }
    });

    // connect to SSE for live updates with reconnect
    (function () {
      var es = null;
      var retries = 0;
      function connect() {
        if (es) try { es.close(); } catch (e) { }
        es = new EventSource('/events');
        es.onmessage = function (ev) {
          retries = 0;
          try {
            const d = JSON.parse(ev.data);
            // numeric updates
            var elReqTotal = document.getElementById('requestsTotal'); if (elReqTotal) elReqTotal.textContent = d.requests_total;
            var elReqPerMin = document.getElementById('requestsPerMin'); if (elReqPerMin) elReqPerMin.textContent = 'Last 60s: ' + d.requests_per_min;
            var elMem = document.getElementById('memAlloc'); if (elMem) elMem.textContent = d.mem_alloc_mb.toFixed(2) + ' MiB';
            var elGr = document.getElementById('goroutines'); if (elGr) elGr.textContent = d.goroutines;
            var elUp = document.getElementById('uptime'); if (elUp) elUp.textContent = d.uptime;
            // update sparkline bars smoothly using raw counts (FIFO ordered)
            var counts = d.counts || [];
            var sp = document.getElementById('sparkline');
            var bars = document.querySelectorAll('#sparkline .bar');
            // compute scale using max of counts and 1
            var max = 1;
            for (var i = 0; i < counts.length; i++) if (counts[i] > max) max = counts[i];
            // if there's an active planned schedule, include its peak so overlay is visible
            if (window.__plannedSchedule && window.__plannedSchedule.length) {
              var peak = Math.max.apply(null, window.__plannedSchedule.concat([0]));
              if (peak > max) max = peak;
            }
            var chartH = 120;
            if (counts.length && bars.length === counts.length) {
              for (var i = 0; i < bars.length; i++) {
                var h = Math.max(2, Math.round((counts[i] / max) * chartH));
                bars[i].setAttribute('data-h', h);
                bars[i].style.height = h + 'px';
                bars[i].setAttribute('title', counts[i]);
              }
            } else if (counts.length) {
              // rebuild bars from counts
              sp.innerHTML = '';
              counts.forEach(function (c) {
                var h = Math.max(2, Math.round((c / max) * chartH));
                var b = document.createElement('div');
                b.className = 'bar';
                b.style.height = h + 'px';
                b.setAttribute('data-h', h);
                b.setAttribute('title', c);
                sp.appendChild(b);
              });
            }
            // render overlay of planned schedule if present
            if (window.__plannedSchedule && window.__plannedSchedule.length) {
              // draw overlay heights onto small semi-transparent bars atop sparkline
              var overlay = document.querySelectorAll('#sparkline .overlay');
              if (overlay.length !== counts.length) {
                // rebuild overlays
                // remove any existing overlay elems
                document.querySelectorAll('#sparkline .overlay').forEach(function (el) { el.remove(); });
                // create overlay divs
                counts.forEach(function () {
                  var ov = document.createElement('div'); ov.className = 'overlay'; ov.style.position = 'absolute'; ov.style.width = '6px'; ov.style.background = 'rgba(124,58,237,0.18)'; ov.style.borderRadius = '3px'; ov.style.bottom = '8px'; ov.style.transition = 'height 300ms ease'; sp.appendChild(ov);
                });
                // position sparkline relatively
                sp.style.position = 'relative';
                // set container child order: bars then overlays
              }
              // compute overlay mapping: align planned schedule to the right of counts
              var ovEls = document.querySelectorAll('#sparkline .overlay');
              var sched = window.__plannedSchedule;
              var start = Math.max(0, counts.length - sched.length);
              for (var i = 0; i < counts.length; i++) {
                var val = 0;
                var idx = i - start;
                if (idx >= 0 && idx < sched.length) val = sched[idx];
                var oh = Math.max(0, Math.round((val / max) * chartH));
                if (ovEls[i]) ovEls[i].style.height = oh + 'px';
              }
            }
            // update client info if present in payload
            if (d.client_ip) { var ci = document.getElementById('clientInfo'); if (ci) ci.textContent = d.client_ip + ' • ' + (d.client_method || '') + ' ' + (d.client_path || ''); }
            if (d.client_ua) { var cua = document.getElementById('clientUA'); if (cua) cua.textContent = 'UA: ' + d.client_ua; }
            if (d.client_headers) {
              var ul = document.getElementById('clientHeadersList');
              if (ul) { ul.innerHTML = ''; for (var k in d.client_headers) { var li = document.createElement('li'); li.innerHTML = '<strong>' + k + ':</strong> ' + d.client_headers[k]; ul.appendChild(li); } }
            }
          } catch (e) { /* noop */ }
        };
        es.onerror = function () {
          // try to reconnect with exponential backoff
          try { es.close(); } catch (e) { }
          es = null;
          retries++;
          var backoff = Math.min(30, Math.pow(2, Math.min(retries, 6))); // seconds
          setTimeout(connect, backoff * 1000);
        };
      }
      // initial connect
      connect();
    })();

    // client-side load tester (supports fixed and ramp modes)
    var loadInterval = null;
    var loadRequests = 0;
    document.getElementById('btn-start-load').addEventListener('click', function () {
      var rps = parseInt(document.getElementById('load-rps').value || '10', 10);
      var dur = parseInt(document.getElementById('load-dur').value || '10', 10);
      var mode = document.getElementById('load-mode').value || 'fixed';
      if (rps <= 0 || dur <= 0) return;
      document.getElementById('btn-start-load').disabled = true;
      document.getElementById('btn-stop-load').disabled = false;
      document.getElementById('load-status').textContent = 'running';
      loadRequests = 0;
      var elapsed = 0;
      // compute per-second schedule depending on mode
      var schedule = [];
      if (mode === 'fixed') {
        for (var t = 0; t < dur; t++) schedule.push(rps);
      } else {
        // ramp mode: rampUp 70%, hold 20%, rampDown 10% (sums to 100%)
        var curve = document.getElementById('curve-type') ? document.getElementById('curve-type').value : 'sigmoid';
        function applyCurve(f) {
          // f is 0..1
          if (curve === 'linear') return f;
          if (curve === 'expo') {
            // ease-in-out exponential-ish
            return (Math.exp(f) - 1) / (Math.E - 1);
          }
          // default sigmoid (smooth S) - normalized logistic-ish
          // using smoothstep-like approximation
          return f * f * (3 - 2 * f);
        }
        var rampUpPct = 0.7, holdPct = 0.2, rampDownPct = 0.1;
        var rampUpSec = Math.max(1, Math.floor(dur * rampUpPct));
        var holdSec = Math.max(0, Math.floor(dur * holdPct));
        var rampDownSec = Math.max(0, dur - rampUpSec - holdSec);
        // linear ramp up from 1 to rps across rampUpSec
        for (var i = 0; i < rampUpSec; i++) {
          var frac = (rampUpSec === 1) ? 1 : (i + 1) / rampUpSec; // 0..1
          var adj = applyCurve(frac);
          var v = Math.max(1, Math.round(1 + adj * (rps - 1)));
          schedule.push(v);
        }
        // hold at near-peak for holdSec
        for (var i = 0; i < holdSec; i++) schedule.push(rps);
        // ramp down to zero over rampDownSec
        for (var i = 0; i < rampDownSec; i++) {
          var frac = (rampDownSec === 1) ? 1 : (i + 1) / rampDownSec; // 0..1
          var adj = applyCurve(1 - frac);
          var v = Math.max(0, Math.round(rps * adj));
          schedule.push(v);
        }
        // normalize schedule length
        while (schedule.length < dur) schedule.push(0);
        if (schedule.length > dur) schedule = schedule.slice(0, dur);
      }

      // expose planned schedule for overlay and draw preview
      window.__plannedSchedule = schedule.slice();
      drawCurve(window.__plannedSchedule);
      // schedule per-second bursts based on schedule array
      var idx = 0;
      loadInterval = setInterval(function () {
        var curRps = schedule[idx] || 0;
        for (var i = 0; i < curRps; i++) {
          fetch('/whoami').then(() => { loadRequests++; }).catch(() => { });
        }
        elapsed++;
        idx++;
        document.getElementById('load-status').textContent = 'sent: ' + loadRequests + ' elapsed: ' + elapsed + 's';
        if (elapsed >= dur) {
          clearInterval(loadInterval); loadInterval = null;
          document.getElementById('btn-start-load').disabled = false;
          document.getElementById('btn-stop-load').disabled = true;
          document.getElementById('load-status').textContent = 'done, sent: ' + loadRequests;
        }
      }, 1000);
    });
    document.getElementById('btn-stop-load').addEventListener('click', function () {
      if (loadInterval) clearInterval(loadInterval);
      loadInterval = null;
      document.getElementById('btn-start-load').disabled = false;
      document.getElementById('btn-stop-load').disabled = true;
      document.getElementById('load-status').textContent = 'stopped';
      // clear planned curve
      window.__plannedSchedule = [];
      drawCurve([]);
    });

    // initial warm fetch for version and readiness
    fetchText('/version', 'out-version');
    fetchText('/ready', 'out-ready');

    // draw planned RPS curve into the small SVG
    function drawCurve(schedule) {
      var svg = document.getElementById('load-curve');
      if (!svg) return;
      // clear
      while (svg.firstChild) svg.removeChild(svg.firstChild);
      if (!schedule || schedule.length === 0) return;
      var w = svg.getAttribute('width') * 1, h = svg.getAttribute('height') * 1;
      var max = Math.max.apply(null, schedule.concat([1]));
      var points = [];
      for (var i = 0; i < schedule.length; i++) {
        var x = (i / (schedule.length - 1)) * (w - 8) + 4;
        var y = h - Math.round((schedule[i] / max) * (h - 8)) - 4;
        points.push([x, y]);
      }
      // create path
      var ns = 'http://www.w3.org/2000/svg';
      var path = document.createElementNS(ns, 'path');
      var d = '';
      for (var i = 0; i < points.length; i++) {
        var p = points[i];
        if (i === 0) d += 'M ' + p[0] + ' ' + p[1]; else d += ' L ' + p[0] + ' ' + p[1];
      }
      path.setAttribute('d', d);
      path.setAttribute('stroke', '#7c3aed');
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('stroke-opacity', '0.9');
      svg.appendChild(path);
      // fill under curve
      var poly = document.createElementNS(ns, 'path');
      var d2 = d + ' L ' + (points[points.length - 1][0]) + ' ' + (h - 2) + ' L ' + (points[0][0]) + ' ' + (h - 2) + ' Z';
      poly.setAttribute('d', d2);
      poly.setAttribute('fill', '#7c3aed');
      poly.setAttribute('fill-opacity', '0.08');
      svg.appendChild(poly);
    }
  </script>

</body>

</html>
